using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Drawing;
using System.Drawing.Imaging;
using System.Globalization;
using System.Linq;
using Leap;

namespace CVLeap
{
	internal class ImageProvider
	{
		private ImageListener listener;
		private Controller controller;

		public ImageProvider()
		{
			Console.WriteLine("Image provider created.");
			controller = new Controller();
			controller.SetPolicy(Controller.PolicyFlag.POLICY_IMAGES);

			listener = new ImageListener();

			controller.AddListener(listener);


		}

		public void AddNewAction(Action<Bitmap[]> newAction)
		{
			listener.OnNewImages += newAction;
		}
	}

	internal class ImageListener : Listener
	{
		public ImageListener()
		{
			Console.WriteLine("Listener listens.");
			sw = new Stopwatch();
			sw.Start();
		}

		public override void OnImages(Controller controller)
		{
			try
			{
				if (sw.ElapsedMilliseconds < 50)
					return;

				sw.Reset();
				Console.WriteLine("Got new images.");
				var images = controller.Images
					.Select(Undistort)
					.Select(GrayscaleBitmapConverter.Convert)
					.ToArray();
				if (OnNewImages != null)
					OnNewImages(images);
				sw.Start();
			}
			catch (Exception ex)
			{
				Console.WriteLine(ex);
			}
		}

		public Action<Bitmap[]> OnNewImages;

		public byte[,] Undistort(Leap.Image img)
		{
			float destinationWidth = 320;
			float destinationHeight = 120;
			byte[,] destination = new byte[(int)destinationWidth, (int)destinationHeight];

			var raw = img.Data;
			var distortionBuffer = img.Distortion;

			var distortionWidth = img.DistortionWidth;
			var width = img.Width;
			var height = img.Height;

			for (int i = 0; i < destinationWidth; i++)
			{
				for (int j = 0; j < destinationHeight; j++)
				{
					float calibrationX = 63 * i / destinationWidth;
					float calibrationY = 62 * (1 - j / destinationHeight);
					float weightX = calibrationX - (int)calibrationX;
					float weightY = calibrationY - (int)calibrationY;
					int x1 = (int)calibrationX;
					int y1 = (int)calibrationY;
					int x2 = x1 + 1;
					int y2 = y1 + 1;

					float dX1 = distortionBuffer[x1 * 2 + y1 * distortionWidth];
					float dX2 = distortionBuffer[x2 * 2 + y1 * distortionWidth];
					float dX3 = distortionBuffer[x1 * 2 + y2 * distortionWidth];
					float dX4 = distortionBuffer[x2 * 2 + y2 * distortionWidth];
					float dY1 = distortionBuffer[x1 * 2 + y1 * distortionWidth + 1];
					float dY2 = distortionBuffer[x2 * 2 + y1 * distortionWidth + 1];
					float dY3 = distortionBuffer[x1 * 2 + y2 * distortionWidth + 1];
					float dY4 = distortionBuffer[x2 * 2 + y2 * distortionWidth + 1];

					float dX = dX1 * (1 - weightX) * (1 - weightY) +
							   dX2 * weightX * (1 - weightY) +
							   dX3 * (1 - weightX) * weightY +
							   dX4 * weightX * weightY;
					float dY = dY1 * (1 - weightX) * (1 - weightY) +
							   dY2 * weightX * (1 - weightY) +
							   dY3 * (1 - weightX) * weightY +
							   dY4 * weightX * weightY;

					if ((dX >= 0) && (dX <= 1) && (dY >= 0) && (dY <= 1))
					{
						int denormalizedX = (int)dX * width;
						int denormalizedY = (int)dY * height;

						destination[i, j] = raw[denormalizedX + denormalizedY * width];


					}
					else
					{
						destination[i, j] = 0;
					}
				}
			}


			return destination;
		}

		private Stopwatch sw;


	}

	internal static class GrayscaleBitmapConverter
	{
		public static Bitmap Convert(byte[,] image)
		{
			int width = image.GetLength(0);
			int height = image.GetLength(1);
			var bitmap = new Bitmap(width, height, PixelFormat.Format8bppIndexed);
			ColorPalette grayscale = bitmap.Palette;
			for (int i = 0; i < 256; i++)
			{
				grayscale.Entries[i] = Color.FromArgb((int)255, i, i, i);
			}
			bitmap.Palette = grayscale;
			Rectangle lockArea = new Rectangle(0, 0, bitmap.Width, bitmap.Height);
			BitmapData bitmapData = bitmap.LockBits(lockArea, ImageLockMode.WriteOnly, PixelFormat.Format8bppIndexed);
			List<byte> rawImageData = new List<byte>();
			for (int i = 0; i < width; i++)
			{
				for (int j = 0; j < height; j++)
				{
					rawImageData.Add(image[i, j]);
				}
			}
			System.Runtime.InteropServices.Marshal.Copy(rawImageData.ToArray(), 0, bitmapData.Scan0, width * height);
			bitmap.UnlockBits(bitmapData);
			return bitmap;
		}
	}
}